apiVersion: v1
kind: ConfigMap
metadata:
  name: immich-config
  namespace: immich
data:
  # Database Connection
  DB_HOSTNAME: "immich-db"
  DB_USERNAME: "immich"
  DB_DATABASE_NAME: "immich"
  DB_PORT: "5432"

  # Redis Connection
  REDIS_HOSTNAME: "immich-redis"
  REDIS_PORT: "6379"
  
  # Application Settings
  NODE_ENV: "production"
  IMMICH_ENV: "production"
  
  # Folder paths (internal container paths)
  UPLOAD_LOCATION: "/usr/src/app/upload"
  IMMICH_MACHINE_LEARNING_URL: "http://immich-machine-learning:3003"
  
  TZ: "Europe/Dublin"

  # Sidecar Scripts
  sync-daemon.sh: |
    #!/bin/sh
    set -e
    
    # Install dependencies
    # apk add --no-cache rsync inotify-tools
    # (Moved to container command to avoid re-installing every loop if script restarts, 
    # but for simplicity in this script we assume they are present or installed by command)
    
    UPLOAD_DIR="/usr/src/app/upload/upload"
    NAS_DIR="/usr/src/app/upload/library/new-uploads"
    QUEUE_LOG="/usr/src/app/upload/sync-queue/sync.log"
    LOCK_FILE="/tmp/sync.lock"
    
    echo "Starting Sync Daemon..."
    echo "Watching $UPLOAD_DIR"
    echo "Syncing to $NAS_DIR"
    
    # Ensure sync queue directory exists
    mkdir -p "$(dirname "$QUEUE_LOG")"
    
    perform_sync() {
        if [ -f "$LOCK_FILE" ]; then
            echo "Sync already in progress, skipping."
            return
        fi
        
        touch "$LOCK_FILE"
        
        # Check if NAS is reachable (simple directory check)
        if timeout 5 ls -d "$(dirname "$NAS_DIR")" >/dev/null 2>&1; then
            echo "[$(date)] NAS available. Starting sync..." >> "$QUEUE_LOG"
            
            # Ensure destination exists
            mkdir -p "$NAS_DIR" 2>/dev/null || true
            
            # Rsync command
            # -a: archive mode
            # -v: verbose
            # --ignore-existing: skip files that exist on receiver
            # --remove-source-files: OPTIONAL - Guide says "Copies", implies retention on SSD cache?
            # Guide says: "Scenario A: ... /data/upload (SSD) -> /data/library (NAS) ... Recent in cache on SSD"
            # So we DO NOT remove source files. We keep them on SSD as cache.
            
            if rsync -av --ignore-existing "$UPLOAD_DIR/" "$NAS_DIR/"; then
                echo "[$(date)] Sync completed successfully." >> "$QUEUE_LOG"
            else
                echo "[$(date)] Sync failed with error code $?." >> "$QUEUE_LOG"
            fi
        else
            echo "[$(date)] NAS unavailable. Queueing uploads on SSD." >> "$QUEUE_LOG"
        fi
        
        rm -f "$LOCK_FILE"
    }
    
    # Initial sync on startup
    perform_sync
    
    # Watch for new files
    # -m: monitor
    # -r: recursive
    # -e: events (close_write, moved_to) - triggered when file upload finishes
    inotifywait -m -r -e close_write,moved_to --format '%w%f' "$UPLOAD_DIR" | while read FILE
    do
        echo "Detected new file: $FILE"
        # Wait a brief moment for batched uploads or file locks
        sleep 2
        perform_sync
    done

  resilience-monitor.sh: |
    #!/bin/sh
    
    NAS_MOUNT="/usr/src/app/upload/library"
    LOG_FILE="/usr/src/app/upload/sync-queue/resilience.log"
    STATUS_FILE="/usr/src/app/upload/sync-queue/nas-status"
    
    echo "Starting Resilience Monitor..."
    echo "Monitoring $NAS_MOUNT"
    
    # Ensure log directory exists
    mkdir -p "$(dirname "$LOG_FILE")"
    
    while true; do
        TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        
        # Check if we can list the NAS directory
        if timeout 10 ls -d "$NAS_MOUNT" >/dev/null 2>&1; then
            # Check if it was previously unavailable to log recovery
            if [ -f "$STATUS_FILE" ] && grep -q "UNAVAILABLE" "$STATUS_FILE"; then
                echo "[$TIMESTAMP] NAS Recovery Detected. Status: AVAILABLE" >> "$LOG_FILE"
            fi
            
            echo "AVAILABLE" > "$STATUS_FILE"
        else
            echo "[$TIMESTAMP] NAS Unavailable. Status: UNAVAILABLE" >> "$LOG_FILE"
            echo "UNAVAILABLE" > "$STATUS_FILE"
        fi
        
        # Check every 30 seconds
        sleep 30
    done
